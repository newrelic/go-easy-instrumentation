--- a/client/client.go
+++ b/client/client.go
@@ -6,24 +6,30 @@
 import (
 	"context"
 	"fmt"
+	"grpc-app/sampleapp"
 	"io"
+	"time"
 
-	"grpc-app/sampleapp"
-
+	"github.com/newrelic/go-agent/v3/integrations/nrgrpc"
+	"github.com/newrelic/go-agent/v3/newrelic"
 	"google.golang.org/grpc"
 )
 
-func doUnaryUnary(ctx context.Context, client sampleapp.SampleApplicationClient) {
+func doUnaryUnary(ctx context.Context, client sampleapp.SampleApplicationClient, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("doUnaryUnary").End()
 	msg, err := client.DoUnaryUnary(ctx, &sampleapp.Message{Text: "Hello DoUnaryUnary"})
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
 	fmt.Println(msg.Text)
 }
 
-func doUnaryStream(ctx context.Context, client sampleapp.SampleApplicationClient) {
+func doUnaryStream(ctx context.Context, client sampleapp.SampleApplicationClient, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("doUnaryStream").End()
 	stream, err := client.DoUnaryStream(ctx, &sampleapp.Message{Text: "Hello DoUnaryStream"})
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
 	for {
@@ -32,19 +24,23 @@
 			break
 		}
 		if err != nil {
+			nrTxn.NoticeError(err)
 			panic(err)
 		}
 		fmt.Println(msg.Text)
 	}
 }
 
-func doStreamUnary(ctx context.Context, client sampleapp.SampleApplicationClient) {
+func doStreamUnary(ctx context.Context, client sampleapp.SampleApplicationClient, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("doStreamUnary").End()
 	stream, err := client.DoStreamUnary(ctx)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
 	for i := 0; i < 3; i++ {
 		if err := stream.Send(&sampleapp.Message{Text: "Hello DoStreamUnary"}); err != nil {
+			nrTxn.NoticeError(err)
 			if err == io.EOF {
 				break
 			}
@@ -53,18 +37,22 @@
 	}
 	msg, err := stream.CloseAndRecv()
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
 	fmt.Println(msg.Text)
 }
 
-func doStreamStream(ctx context.Context, client sampleapp.SampleApplicationClient) {
+func doStreamStream(ctx context.Context, client sampleapp.SampleApplicationClient, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("doStreamStream").End()
 	stream, err := client.DoStreamStream(ctx)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
 	waitc := make(chan struct{})
-	go func() {
+	go func(nrTxn *newrelic.Transaction) {
+		defer nrTxn.StartSegment("async literal").End()
 		for {
 			msg, err := stream.Recv()
 			if err == io.EOF {
@@ -72,13 +50,15 @@
 				return
 			}
 			if err != nil {
+				nrTxn.NoticeError(err)
 				panic(err)
 			}
 			fmt.Println(msg.Text)
 		}
-	}()
+	}(nrTxn.NewGoroutine())
 	for i := 0; i < 3; i++ {
 		if err := stream.Send(&sampleapp.Message{Text: "Hello DoStreamStream"}); err != nil {
+			nrTxn.NoticeError(err)
 			panic(err)
 		}
 	}
@@ -86,18 +60,27 @@
 	<-waitc
 }
 
-func doClientCalls(ctx context.Context, client sampleapp.SampleApplicationClient) {
-	doUnaryUnary(ctx, client)
-	doUnaryStream(ctx, client)
-	doStreamUnary(ctx, client)
-	doStreamStream(ctx, client)
+func doClientCalls(ctx context.Context, client sampleapp.SampleApplicationClient, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("doClientCalls").End()
+	doUnaryUnary(ctx, client, nrTxn)
+	doUnaryStream(ctx, client, nrTxn)
+	doStreamUnary(ctx, client, nrTxn)
+	doStreamStream(ctx, client, nrTxn)
 }
 
 func main() {
+	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigAppName("grpc app"), newrelic.ConfigFromEnvironment())
+	if err != nil {
+		panic(err)
+	}
+
 	conn, err := grpc.Dial(
 		"localhost:8080",
+		grpc.WithUnaryInterceptor(nrgrpc.UnaryClientInterceptor),
+		grpc.WithStreamInterceptor(nrgrpc.StreamClientInterceptor),
 	)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
 	defer conn.Close()
@@ -105,5 +81,9 @@
 	client := sampleapp.NewSampleApplicationClient(conn)
 	ctx := context.Background()
 
-	doClientCalls(ctx, client)
+	nrTxn := NewRelicAgent.StartTransaction("doClientCalls")
+	doClientCalls(ctx, client, nrTxn)
+	nrTxn.End()
+
+	NewRelicAgent.Shutdown(5 * time.Second)
 }
--- a/server/server.go
+++ b/server/server.go
@@ -6,11 +6,13 @@
 import (
 	"context"
 	fmt "fmt"
+	"grpc-app/sampleapp"
 	"io"
 	"net"
+	"time"
 
-	"grpc-app/sampleapp"
-
+	"github.com/newrelic/go-agent/v3/integrations/nrgrpc"
+	"github.com/newrelic/go-agent/v3/newrelic"
 	"google.golang.org/grpc"
 )
 
@@ -18,16 +17,20 @@
 type Server struct{}
 
 // processMessage processes each incoming Message.
-func processMessage(ctx context.Context, msg *sampleapp.Message) error {
+func processMessage(ctx context.Context, msg *sampleapp.Message, nrTxn *newrelic.Transaction) error {
+	defer nrTxn.StartSegment("processMessage").End()
 	fmt.Printf("Message received: %s\n", msg.Text)
 	return nil
 }
 
 // DoUnaryUnary is a unary request, unary response method.
 func (s *Server) DoUnaryUnary(ctx context.Context, msg *sampleapp.Message) (*sampleapp.Message, error) {
-	processMessage(ctx, msg)
+	nrTxn := newrelic.FromContext(ctx)
+
+	processMessage(ctx, msg, nrTxn)
 	err := msg.XXX_Unmarshal(nil)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		return &sampleapp.Message{Text: "DoUnaryUnary Error"}, err
 	}
 	return &sampleapp.Message{Text: "Hello from DoUnaryUnary"}, nil
@@ -74,12 +69,23 @@
 }
 
 func main() {
+	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigAppName("grpc app"), newrelic.ConfigFromEnvironment())
+	if err != nil {
+		panic(err)
+	}
+
 	lis, err := net.Listen("tcp", "localhost:8080")
 	if err != nil {
+		nrTxn.NoticeError(err)
 		panic(err)
 	}
-	grpcServer := grpc.NewServer()
+	grpcServer := grpc.NewServer(
+		grpc.UnaryInterceptor(nrgrpc.UnaryServerInterceptor(NewRelicAgent)),
+		grpc.StreamInterceptor(nrgrpc.StreamServerInterceptor(NewRelicAgent)),
+	)
 	server := &Server{}
 	sampleapp.RegisterSampleApplicationServer(grpcServer, server)
 	grpcServer.Serve(lis)
+
+	NewRelicAgent.Shutdown(5 * time.Second)
 }
