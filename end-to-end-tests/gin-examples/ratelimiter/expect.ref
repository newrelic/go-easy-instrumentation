--- a/rate.go
+++ b/rate.go
@@ -7,6 +7,8 @@
 
 	"github.com/fatih/color"
 	"github.com/gin-gonic/gin"
+	"github.com/newrelic/go-agent/v3/integrations/nrgin"
+	"github.com/newrelic/go-agent/v3/newrelic"
 	"go.uber.org/ratelimit"
 )
 
@@ -21,7 +23,9 @@
 	log.SetOutput(gin.DefaultWriter)
 }
 
-func leakBucket() gin.HandlerFunc {
+func leakBucket(nrTxn *newrelic.Transaction) gin.HandlerFunc {
+	defer nrTxn.StartSegment("leakBucket").End()
+
 	prev := time.Now()
 	return func(ctx *gin.Context) {
 		now := limit.Take()
@@ -30,13 +34,22 @@
 	}
 }
 
-func ginRun(rps int) {
+func ginRun(rps int, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("ginRun").End()
+
 	limit = ratelimit.New(rps)
 
 	app := gin.Default()
-	app.Use(leakBucket())
+	app.Use(nrgin.Middleware(nrTxn.Application()))
+	app.Use(leakBucket(nrTxn))
 
+	// NR WARN: Since the handler function name is used as the transaction name,
+	// anonymous functions do not get usefully named.
+	// We encourage transforming anonymous functions into named functions
 	app.GET("/rate", func(ctx *gin.Context) {
+		nrTxn := nrgin.Transaction(ctx)
+
+		defer nrTxn.StartSegment("/rate").End()
 		ctx.JSON(200, "rate limiting test")
 	})
 
@@ -45,6 +53,15 @@
 }
 
 func main() {
+	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
+	if err != nil {
+		panic(err)
+	}
+
 	flag.Parse()
-	ginRun(*rps)
+	nrTxn := NewRelicAgent.StartTransaction("ginRun")
+	ginRun(*rps, nrTxn)
+	nrTxn.End()
+
+	NewRelicAgent.Shutdown(5 * time.Second)
 }
