--- a/main.go
+++ b/main.go
@@ -10,6 +10,8 @@
 	"os"
 	"sync"
 	"time"
+
+	"github.com/newrelic/go-agent/v3/newrelic"
 )
 
 // the most basic http handler function
@@ -18,6 +20,9 @@
 }
 
 func anotherFuncWithAContext(ctx context.Context) {
+	nrTxn := newrelic.FromContext(ctx)
+	defer nrTxn.StartSegment("anotherFuncWithAContext").End()
+
 	val := ctx.Value("key")
 	if val != nil {
 		slog.Info("we found the key!", slog.Any("key", val))
@@ -25,36 +30,51 @@
 }
 
 func aFunctionWithContextArguments(ctx context.Context) {
+	nrTxn := newrelic.FromContext(ctx)
+	defer nrTxn.StartSegment("aFunctionWithContextArguments").End()
+
 	// do something
 	err := ctx.Err()
 	if err != nil {
+		nrTxn.NoticeError(err)
 		return
 	}
 
-	DoAThing(false)
+	DoAThing(false, nrTxn)
 	anotherFuncWithAContext(ctx)
 }
 
-func DoAThing(willError bool) (string, bool, error) {
+func DoAThing(willError bool, nrTxn *newrelic.Transaction) (string, bool, error) {
+	defer nrTxn.StartSegment("DoAThing").End()
+
 	time.Sleep(200 * time.Millisecond)
 	if willError {
-		return "thing not done", false, errors.New("this is an error")
+		// generated by go-easy-instrumentation; returnValue0:error
+		returnValue0 := errors.New("this is an error")
+		if returnValue0 != nil {
+			nrTxn.NoticeError(returnValue0)
+		}
+
+		return "thing not done", false, returnValue0
 	}
 
 	return "thing complete", true, nil
 }
 
 func noticeError(w http.ResponseWriter, req *http.Request) {
-	err := pkg.Service()
+	nrTxn := newrelic.FromContext(req.Context())
+
+	err := pkg.Service(nrTxn)
 	if err != nil {
 		io.WriteString(w, err.Error())
 		return
 	}
 
-	aFunctionWithContextArguments(req.Context())
+	aFunctionWithContextArguments(newrelic.NewContext(req.Context(), nrTxn))
 
-	str, _, err := DoAThing(true)
+	str, _, err := DoAThing(true, nrTxn)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		io.WriteString(w, err.Error())
 	} else {
 		io.WriteString(w, str+" no errors occured")
@@ -62,15 +58,22 @@
 }
 
 func external(w http.ResponseWriter, r *http.Request) {
+	nrTxn := newrelic.FromContext(r.Context())
+
 	req, err := http.NewRequest("GET", "https://example.com", nil)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		slog.Error(err.Error())
 		return
 	}
 
 	// Make an http request to an external address
+	externalSegment := newrelic.StartExternalSegment(nrTxn, req)
 	resp, err := http.DefaultClient.Do(req)
+	externalSegment.Response = resp
+	externalSegment.End()
 	if err != nil {
+		nrTxn.NoticeError(err)
 		io.WriteString(w, err.Error())
 		return
 	}
@@ -80,9 +74,16 @@
 }
 
 func basicExternal(w http.ResponseWriter, r *http.Request) {
+	nrTxn := newrelic.FromContext(r.Context())
+
+	// the "http.Get()" net/http method can not be instrumented and its outbound traffic can not be traced
+	// please see these examples of code patterns for external http calls that can be instrumented:
+	// https://docs.newrelic.com/docs/apm/agents/go-agent/configuration/distributed-tracing-go-agent/#make-http-requests
+	//
 	// Make an http request to an external address
 	resp, err := http.Get("https://example.com")
 	if err != nil {
+		nrTxn.NoticeError(err)
 		slog.Error(err.Error())
 		io.WriteString(w, err.Error())
 		return
@@ -93,19 +91,25 @@
 }
 
 func roundtripper(w http.ResponseWriter, r *http.Request) {
+	nrTxn := newrelic.FromContext(r.Context())
+
 	client := &http.Client{}
+	client.Transport = newrelic.NewRoundTripper(client.Transport)
 	client2 := client // verify that this doesn't get the transport replaced by the parser
 
 	request, err := http.NewRequest("GET", "https://example.com", nil)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		slog.Error(err.Error())
 		return
 	}
 
+	request = newrelic.RequestWithTransactionContext(request, nrTxn)
 	resp, err := client2.Do(request)
 
 	// this is an unusual spacing and comment pattern to test the decoration preservation
 	if err != nil {
+		nrTxn.NoticeError(err)
 		slog.Error(err.Error())
 		io.WriteString(w, err.Error())
 		return
@@ -116,56 +107,79 @@
 }
 
 func async(w http.ResponseWriter, r *http.Request) {
+	nrTxn := newrelic.FromContext(r.Context())
+
 	wg := &sync.WaitGroup{}
 	wg.Add(1)
-	go func() {
+	go func(nrTxn *newrelic.Transaction) {
+		defer nrTxn.StartSegment("async function literal").End()
+
 		defer wg.Done()
 		time.Sleep(100 * time.Millisecond)
-	}()
+	}(nrTxn.NewGoroutine())
 	wg.Wait()
 	w.Write([]byte("done!"))
 }
 
-func doAsyncThing(wg *sync.WaitGroup) {
+func doAsyncThing(wg *sync.WaitGroup, nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("async doAsyncThing").End()
+
 	defer wg.Done()
 	time.Sleep(100 * time.Millisecond)
+	// the "http.Get()" net/http method can not be instrumented and its outbound traffic can not be traced
+	// please see these examples of code patterns for external http calls that can be instrumented:
+	// https://docs.newrelic.com/docs/apm/agents/go-agent/configuration/distributed-tracing-go-agent/#make-http-requests
 	_, err := http.Get("http://example.com")
 	if err != nil {
+		nrTxn.NoticeError(err)
 		slog.Error(err.Error())
 	}
 }
 
 func async2(w http.ResponseWriter, r *http.Request) {
+	nrTxn := newrelic.FromContext(r.Context())
+
 	wg := &sync.WaitGroup{}
 	wg.Add(1)
-	go doAsyncThing(wg)
+	go doAsyncThing(wg, nrTxn.NewGoroutine())
 
-	go aFunctionWithContextArguments(r.Context())
+	go aFunctionWithContextArguments(newrelic.NewContext(r.Context(), nrTxn.NewGoroutine()))
 	wg.Wait()
 	w.Write([]byte("done!"))
 }
 
 // design pattern that forces awareness of call depth to pass instrumentation
-func initServer() {
-	http.HandleFunc("/", index)
-	http.HandleFunc("/error", noticeError)
-	http.HandleFunc("/external", external)
-	http.HandleFunc("/roundtrip", roundtripper)
-	http.HandleFunc("/basicExternal", basicExternal)
-	http.HandleFunc("/async", async)
-	http.HandleFunc("/async2", async2)
-	http.HandleFunc("/packaged", pkg.PackagedHandler)
+func initServer(nrTxn *newrelic.Transaction) {
+	defer nrTxn.StartSegment("initServer").End()
 
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/", index))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/error", noticeError))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/external", external))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/roundtrip", roundtripper))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/basicExternal", basicExternal))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/async", async))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/async2", async2))
+	http.HandleFunc(newrelic.WrapHandleFunc(nrTxn.Application(), "/packaged", pkg.PackagedHandler))
+
 	// this should no longer get ignored
-	DoAThing(true)
+	DoAThing(true, nrTxn)
 }
 
 func main() {
+	NewRelicAgent, agentInitError := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
+	if agentInitError != nil {
+		panic(agentInitError)
+	}
+
 	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{}))
 	slog.SetDefault(logger)
 
 	slog.Info("starting server at localhost:8000")
-	initServer()
+	nrTxn := NewRelicAgent.StartTransaction("initServer")
+	initServer(nrTxn)
+	nrTxn.End()
 
 	http.ListenAndServe(":8000", nil)
+
+	NewRelicAgent.Shutdown(5 * time.Second)
 }
--- a/main_test.go
+++ b/main_test.go
@@ -38,14 +38,14 @@
 
 func TestDoAThing(t *testing.T) {
 	t.Run("without error", func(t *testing.T) {
-		result, success, err := DoAThing(false)
+		result, success, err := DoAThing(false, nil)
 		assert.NoError(t, err)
 		assert.Equal(t, "thing complete", result)
 		assert.True(t, success)
 	})
 
 	t.Run("with error", func(t *testing.T) {
-		result, success, err := DoAThing(true)
+		result, success, err := DoAThing(true, nil)
 		assert.Error(t, err)
 		assert.Equal(t, "thing not done", result)
 		assert.False(t, success)
--- a/pkg/service.go
+++ b/pkg/service.go
@@ -4,17 +4,25 @@
 	"fmt"
 	"log/slog"
 	"net/http"
+
+	"github.com/newrelic/go-agent/v3/newrelic"
 )
 
-func Service() error {
-	req, err := buildGetRequest("https://example.com")
+func Service(nrTxn *newrelic.Transaction) error {
+	defer nrTxn.StartSegment("Service").End()
+
+	req, err := buildGetRequest("https://example.com", nrTxn)
 	if err != nil {
 		return err
 	}
 
 	// Make an http request to an external address
+	externalSegment := newrelic.StartExternalSegment(nrTxn, req)
 	resp, err := http.DefaultClient.Do(req)
+	externalSegment.Response = resp
+	externalSegment.End()
 	if err != nil {
+		nrTxn.NoticeError(err)
 		return err
 	}
 
@@ -22,12 +21,22 @@
 	return nil
 }
 
-func buildGetRequest(path string) (*http.Request, error) {
+func buildGetRequest(path string, nrTxn *newrelic.Transaction) (*http.Request, error) {
+	defer nrTxn.StartSegment("buildGetRequest").End()
+
 	req, err := http.NewRequest("GET", path, nil)
 	if err != nil {
+		nrTxn.NoticeError(err)
 		errMsg := fmt.Sprintf("failed to build request: %v", err)
 		slog.Error(errMsg)
-		return nil, fmt.Errorf(errMsg)
+
+		// generated by go-easy-instrumentation; returnValue0:error
+		returnValue0 := fmt.Errorf(errMsg)
+		if returnValue0 != nil {
+			nrTxn.NoticeError(returnValue0)
+		}
+
+		return nil, returnValue0
 	}
 	return req, nil
 }
