package parser

import (
	"testing"

	"github.com/dave/dst"
	"github.com/newrelic/go-easy-instrumentation/internal/codegen"
	"github.com/stretchr/testify/assert"
)

func Test_isNewRelicMethod(t *testing.T) {
	type args struct {
		call *dst.CallExpr
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Decorated DST New Relic Method",
			args: args{
				call: &dst.CallExpr{
					Fun: &dst.Ident{
						Name: "txn",
						Path: codegen.NewRelicAgentImportPath,
					},
				},
			},
			want: true,
		},
		{
			name: "AST Style New Relic Method",
			args: args{
				call: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X: &dst.Ident{
							Name: "newrelic",
						},
						Sel: &dst.Ident{
							Name: "StartTransaction",
						},
					},
				},
			},
			want: true,
		},
		{
			name: "Non New Relic Method",
			args: args{
				call: &dst.CallExpr{
					Fun: &dst.Ident{
						Name: "Get",
						Path: codegen.HttpImportPath,
					},
				},
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := isNewRelicMethod(tt.args.call); got != tt.want {
				t.Errorf("isNewRelicMethod() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_noticeError(t *testing.T) {
	tests := []struct {
		name   string
		code   string
		expect string
	}{
		{
			name: "error gets noticed in upstream function call",
			code: `package main

import "net/http"

func test() {
_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	test()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func test(nrTxn *newrelic.Transaction) {
	defer nrTxn.StartSegment("test").End()

	_, err := http.Get("http://example.com")
	if err != nil {
		nrTxn.NoticeError(err)
		panic(err)
	}
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("test")
	test(nrTxn)
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "unchecked error gets captured",
			code: `package main

import "net/http"

func test() error{
	_, err := http.Get("http://example.com")
	return err
}

func main() {
	test()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func test(nrTxn *newrelic.Transaction) error {
	defer nrTxn.StartSegment("test").End()

	_, err := http.Get("http://example.com")

	if err != nil {
		nrTxn.NoticeError(err)
	}
	return err
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("test")
	test(nrTxn)
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "ignored error returns get ignored",
			code: `package main

import "net/http"

func test() {
	_, _ := http.Get("http://example.com")
}

func main() {
	test()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func test(nrTxn *newrelic.Transaction) {
	defer nrTxn.StartSegment("test").End()

	_, _ := http.Get("http://example.com")
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("test")
	test(nrTxn)
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "upstream error return gets assigned and noticed",
			code: `package main

import (
	"log"
	"net/http"
)

func test() (any,error){
	return http.Get("http://example.com")
}

func main() {
	_, err := test()
	if err != nil {
		log.Fatal(err)
	}
}
`,
			expect: `package main

import (
	"log"
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func test(nrTxn *newrelic.Transaction) (any, error) {
	defer nrTxn.StartSegment("test").End()

	// generated by go-easy-instrumentation; returnValue0:*net/http.Response, returnValue1:error
	returnValue0, returnValue1 := http.Get("http://example.com")
	if returnValue1 != nil {
		nrTxn.NoticeError(returnValue1)
	}

	return returnValue0, returnValue1
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("test")
	_, err := test(nrTxn)
	nrTxn.End()
	if err != nil {
		log.Fatal(err)
	}

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "errors in main get ignored",
			code: `package main

import "net/http"


func main() {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer panicRecovery(t)
			got := testStatelessTracingFunction(t, tt.code, InstrumentMain)
			assert.Equal(t, tt.expect, got)
		})
	}
}

func TestInstrumentMain(t *testing.T) {
	tests := []struct {
		name   string
		code   string
		expect string
	}{
		{
			name: "function with tracing",
			code: `package main

import "net/http"

func myFunc() {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	myFunc()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func myFunc(nrTxn *newrelic.Transaction) {
	defer nrTxn.StartSegment("myFunc").End()

	_, err := http.Get("http://example.com")
	if err != nil {
		nrTxn.NoticeError(err)
		panic(err)
	}
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("myFunc")
	myFunc(nrTxn)
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "re-assigns transaction variable when repeated",
			code: `package main

import "net/http"

func myFunc() {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	myFunc()
	myFunc()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func myFunc(nrTxn *newrelic.Transaction) {
	defer nrTxn.StartSegment("myFunc").End()

	_, err := http.Get("http://example.com")
	if err != nil {
		nrTxn.NoticeError(err)
		panic(err)
	}
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("myFunc")
	myFunc(nrTxn)
	nrTxn.End()
	nrTxn = NewRelicAgent.StartTransaction("myFunc")
	myFunc(nrTxn)
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "pass transaction into context if possible",
			code: `package main

import (
	"context"
	"net/http"
	"time"
)

func myFunc(ctx context.Context) {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	ctx := context.Background()
	myFunc(ctx)
}
`,
			expect: `package main

import (
	"context"
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func myFunc(ctx context.Context) {
	nrTxn := newrelic.FromContext(ctx)
	defer nrTxn.StartSegment("myFunc").End()

	_, err := http.Get("http://example.com")
	if err != nil {
		nrTxn.NoticeError(err)
		panic(err)
	}
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	ctx := context.Background()
	nrTxn := NewRelicAgent.StartTransaction("myFunc")
	myFunc(newrelic.NewContext(ctx, nrTxn))
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "re-assigns transaction variable when repeated",
			code: `package main

import "net/http"

func myFunc() {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	myFunc()
	myFunc()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func myFunc(nrTxn *newrelic.Transaction) {
	defer nrTxn.StartSegment("myFunc").End()

	_, err := http.Get("http://example.com")
	if err != nil {
		nrTxn.NoticeError(err)
		panic(err)
	}
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	nrTxn := NewRelicAgent.StartTransaction("myFunc")
	myFunc(nrTxn)
	nrTxn.End()
	nrTxn = NewRelicAgent.StartTransaction("myFunc")
	myFunc(nrTxn)
	nrTxn.End()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
		{
			name: "ignore async functions in main",
			code: `package main

import "net/http"

func myFunc() {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	go myFunc()
}
`,
			expect: `package main

import (
	"net/http"
	"time"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func myFunc() {
	_, err := http.Get("http://example.com")
	if err != nil {
		panic(err)
	}
}

func main() {
	NewRelicAgent, err := newrelic.NewApplication(newrelic.ConfigFromEnvironment())
	if err != nil {
		panic(err)
	}

	// NR INFO: go-easy-instrumentation doesn't support tracing goroutines in a main method; please instrument manually.
	// https://docs.newrelic.com/docs/apm/agents/go-agent/instrumentation/instrument-go-transactions/#goroutines
	go myFunc()

	NewRelicAgent.Shutdown(5 * time.Second)
}
`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer panicRecovery(t)
			got := testStatelessTracingFunction(t, tt.code, InstrumentMain)
			assert.Equal(t, tt.expect, got)
		})
	}
}
